use crate::{ActionError, Result};
use sampo::{enrich_changeset_message, detect_github_repo_slug};
use std::collections::BTreeMap;
use std::path::Path;
use std::path::PathBuf;
use std::process::Command;

#[derive(Debug)]
pub struct ReleasePlan {
    pub has_changes: bool,
    pub description: String,
}

/// Run sampo release and capture the plan
pub fn capture_release_plan(workspace: &Path) -> Result<ReleasePlan> {
    let mut cmd = Command::new("cargo");
    cmd.arg("run")
        .arg("--manifest-path")
        .arg(workspace.join("Cargo.toml"))
        .arg("-p")
        .arg("sampo")
        .arg("--")
        .arg("release")
        .arg("--dry-run");

    let output = cmd.output().map_err(ActionError::Io)?;
    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    if !output.status.success() {
        return Err(ActionError::SampoCommandFailed {
            operation: "release-plan".to_string(),
            message: format!("stdout: {}\nstderr: {}", stdout, stderr),
        });
    }

    let has_changes = !stdout.contains("No changesets found");

    Ok(ReleasePlan {
        has_changes,
        description: stdout,
    })
}

/// Execute sampo release
pub fn run_release(workspace: &Path, dry_run: bool, cargo_token: Option<&str>) -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("run")
        .arg("--manifest-path")
        .arg(workspace.join("Cargo.toml"))
        .arg("-p")
        .arg("sampo")
        .arg("--")
        .arg("release");

    if dry_run {
        cmd.arg("--dry-run");
    }

    if let Some(token) = cargo_token {
        cmd.env("CARGO_REGISTRY_TOKEN", token);
    }

    let status = cmd.status().map_err(ActionError::Io)?;

    if !status.success() {
        return Err(ActionError::SampoCommandFailed {
            operation: "release".to_string(),
            message: format!("sampo release failed with status {}", status),
        });
    }

    Ok(())
}

/// Execute sampo publish
pub fn run_publish(
    workspace: &Path,
    dry_run: bool,
    extra_args: Option<&str>,
    cargo_token: Option<&str>,
) -> Result<()> {
    let mut cmd = Command::new("cargo");
    cmd.arg("run")
        .arg("--manifest-path")
        .arg(workspace.join("Cargo.toml"))
        .arg("-p")
        .arg("sampo")
        .arg("--")
        .arg("publish");

    if dry_run {
        cmd.arg("--dry-run");
    }

    // Add extra args if provided
    if let Some(args) = extra_args {
        cmd.arg("--");
        for arg in args.split_whitespace() {
            cmd.arg(arg);
        }
    }

    if let Some(token) = cargo_token {
        cmd.env("CARGO_REGISTRY_TOKEN", token);
    }

    let status = cmd.status().map_err(ActionError::Io)?;

    if !status.success() {
        return Err(ActionError::SampoCommandFailed {
            operation: "publish".to_string(),
            message: format!("sampo publish failed with status {}", status),
        });
    }

    Ok(())
}

/// Compute a markdown PR body summarizing the pending release by crate,
/// grouping changes by semantic bump type, and showing old -> new versions.
///
/// This function builds the PR body using stdout from `sampo release --dry-run`
/// to infer planned crate version changes, and reads changesets for change messages.
///
/// # Arguments
/// * `workspace` - Path to the workspace root
/// * `plan_stdout` - Output from `sampo release --dry-run`
///
/// # Returns
/// A formatted markdown string for the PR body, or empty string if no releases are planned
pub fn build_release_pr_body_from_stdout(workspace: &Path, plan_stdout: &str) -> Result<String> {
    let releases = parse_planned_releases(plan_stdout);
    if releases.is_empty() {
        return Ok(String::new());
    }

    let changesets_dir = detect_changesets_dir(workspace);
    let changesets = load_changesets(&changesets_dir)?;

    // Group messages per crate by bump
    let mut messages_by_pkg: BTreeMap<String, Vec<(String, Bump)>> = BTreeMap::new();

    // Resolve GitHub slug and token for commit links and acknowledgments
    let repo_slug = detect_github_repo_slug(workspace);
    let github_token = std::env::var("GITHUB_TOKEN")
        .ok()
        .or_else(|| std::env::var("GH_TOKEN").ok());
    
    for cs in &changesets {
        for pkg in &cs.packages {
            if releases.contains_key(pkg) {
                let enriched = enrich_changeset_message(
                    workspace,
                    &cs.path,
                    &cs.message,
                    repo_slug.as_deref(),
                    github_token.as_deref(),
                );
                messages_by_pkg
                    .entry(pkg.clone())
                    .or_default()
                    .push((enriched, cs.bump));
            }
        }
    }

    // Compose header
    let mut output = String::new();
    output.push_str("This PR was generated by ");
    output.push_str("[Sampo GitHub Action](https://github.com/bruits/sampo/blob/main/crates/sampo-github-action/README.md).");
    output.push_str(" When you're ready to do a release, you can merge this and the packages will be published automatically. ");
    output.push_str("Not ready yet? Just keep adding changesets to the default branch, and this PR will stay up to date.\n\n");
    output.push_str("----\n\n");

    // Deterministic crate order by name
    let mut crate_names: Vec<_> = releases.keys().cloned().collect();
    crate_names.sort();
    for name in crate_names {
        let (old_version, new_version) = &releases[&name];
        output.push_str(&format!(
            "## {} {} -> {}\n\n",
            name, old_version, new_version
        ));

        let mut major_changes = Vec::new();
        let mut minor_changes = Vec::new();
        let mut patch_changes = Vec::new();

        if let Some(changeset_list) = messages_by_pkg.get(&name) {
            for (message, bump_type) in changeset_list {
                match bump_type {
                    Bump::Major => major_changes.push(message.clone()),
                    Bump::Minor => minor_changes.push(message.clone()),
                    Bump::Patch => patch_changes.push(message.clone()),
                }
            }
        }

        append_changes_section(&mut output, "Major changes", &major_changes);
        append_changes_section(&mut output, "Minor changes", &minor_changes);
        append_changes_section(&mut output, "Patch changes", &patch_changes);
    }

    Ok(output)
}

/// Append a changes section to the output if the changes list is not empty
fn append_changes_section(output: &mut String, section_title: &str, changes: &[String]) {
    if !changes.is_empty() {
        output.push_str(&format!("### {}\n\n", section_title));
        for change in changes {
            output.push_str("- ");
            output.push_str(change);
            output.push('\n');
        }
        output.push('\n');
    }
}

/// Semantic version bump types, ordered by impact
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Bump {
    Patch,
    Minor,
    Major,
}

/// Represents a parsed changeset file with package references and change details
#[derive(Debug, Clone)]
struct Changeset {
    path: PathBuf,
    packages: Vec<String>,
    bump: Bump,
    message: String,
}

/// Detect the changesets directory, respecting custom configuration.
///
/// Reads `.sampo/config.toml` to check for a custom `changesets.dir` setting,
/// falling back to the default `.sampo/changesets` directory.
fn detect_changesets_dir(workspace: &Path) -> PathBuf {
    let base = workspace.join(".sampo");
    let cfg_path = base.join("config.toml");
    if cfg_path.exists()
        && let Ok(text) = std::fs::read_to_string(&cfg_path)
        && let Ok(value) = text.parse::<toml::Value>()
        && let Some(dir) = value
            .get("changesets")
            .and_then(|v| v.as_table())
            .and_then(|t| t.get("dir"))
            .and_then(|v| v.as_str())
    {
        return base.join(dir);
    }
    base.join("changesets")
}

/// Load all changeset files from the given directory.
///
/// Scans for `.md` files and parses their frontmatter and content.
fn load_changesets(dir: &Path) -> Result<Vec<Changeset>> {
    if !dir.exists() {
        return Ok(Vec::new());
    }
    let mut out = Vec::new();
    for entry in std::fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        if path.extension().and_then(|e| e.to_str()) != Some("md") {
            continue;
        }
        let text = std::fs::read_to_string(&path)?;
        if let Some(cs) = parse_changeset(&text, &path) {
            out.push(cs);
        }
    }
    Ok(out)
}

/// Parse a changeset file, extracting frontmatter and message content.
///
/// Expected format:
/// ```
/// ---
/// packages:
/// - package-name
/// release: major|minor|patch
/// ---
/// Change description message
/// ```
fn parse_changeset(text: &str, path: &Path) -> Option<Changeset> {
    let mut lines = text.lines();
    if lines.next()?.trim() != "---" {
        return None;
    }
    let mut packages: Vec<String> = Vec::new();
    let mut bump: Option<Bump> = None;
    let mut in_packages = false;
    for line in &mut lines {
        let l = line.trim();
        if l == "---" {
            break;
        }
        if l.starts_with("packages:") {
            in_packages = true;
            continue;
        }
        if in_packages {
            if let Some(rest) = l.strip_prefix('-') {
                let name = rest.trim().to_string();
                if !name.is_empty() {
                    packages.push(name);
                }
                continue;
            } else if !l.is_empty() {
                in_packages = false;
            }
        }
        if let Some(v) = l.strip_prefix("release:") {
            let v = v.trim().to_ascii_lowercase();
            let b = match v.as_str() {
                "patch" | "p" => Some(Bump::Patch),
                "minor" | "mi" => Some(Bump::Minor),
                "major" | "ma" => Some(Bump::Major),
                _ => None,
            };
            if b.is_some() {
                bump = b;
            }
        }
    }
    let remainder: String = lines.collect::<Vec<_>>().join("\n");
    let message = remainder.trim().to_string();
    if packages.is_empty() || bump.is_none() || message.is_empty() {
        return None;
    }
    Some(Changeset {
        path: path.to_path_buf(),
        packages,
        bump: bump.unwrap(),
        message,
    })
}

/// Extract planned release information from sampo dry-run output.
///
/// Looks for lines like "package-name: 0.1.0 -> 0.2.0" and parses them
/// into a map of package name to (old_version, new_version) pairs.
fn parse_planned_releases(stdout: &str) -> BTreeMap<String, (String, String)> {
    // Extract lines like: "  name: 0.1.0 -> 0.2.0"
    let mut map = BTreeMap::new();
    for line in stdout.lines() {
        let l = line.trim();
        if l.is_empty() || !l.contains("->") || !l.contains(':') {
            continue;
        }
        // Split on ':' first
        let mut parts = l.splitn(2, ':');
        let name = parts.next().unwrap().trim().to_string();
        let rest = parts.next().unwrap().trim();
        let mut arrow = rest.splitn(2, "->");
        let old = arrow.next().unwrap().trim().to_string();
        let new_version = arrow.next().unwrap_or("").trim().to_string();
        if !name.is_empty() && !old.is_empty() && !new_version.is_empty() {
            map.insert(name, (old, new_version));
        }
    }
    map
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_parse_planned_releases() {
        let stdout = "Planning release for packages:
  sampo: 0.1.0 -> 0.2.0
  sampo-github-action: 0.0.1 -> 0.1.0
No changesets found for other-pkg";

        let releases = parse_planned_releases(stdout);
        assert_eq!(releases.len(), 2);
        assert_eq!(
            releases.get("sampo"),
            Some(&("0.1.0".to_string(), "0.2.0".to_string()))
        );
        assert_eq!(
            releases.get("sampo-github-action"),
            Some(&("0.0.1".to_string(), "0.1.0".to_string()))
        );
    }

    #[test]
    fn test_parse_planned_releases_empty() {
        let stdout = "No changesets found";
        let releases = parse_planned_releases(stdout);
        assert!(releases.is_empty());
    }

    #[test]
    fn test_parse_changeset_valid() {
        let text = "---
packages:
- sampo
- sampo-github-action
release: minor
---
Add new feature for better PR formatting";

        let changeset = parse_changeset(text, &PathBuf::from("test.md"));
        assert!(changeset.is_some());

        let cs = changeset.unwrap();
        assert_eq!(cs.packages, vec!["sampo", "sampo-github-action"]);
        assert_eq!(cs.bump, Bump::Minor);
        assert_eq!(cs.message, "Add new feature for better PR formatting");
    }

    #[test]
    fn test_parse_changeset_invalid_no_frontmatter() {
        let text = "Just a regular markdown file";
        let changeset = parse_changeset(text, &PathBuf::from("test.md"));
        assert!(changeset.is_none());
    }

    #[test]
    fn test_parse_changeset_missing_required_fields() {
        let text = "---
packages:
- sampo
---
Missing release field";

        let changeset = parse_changeset(text, &PathBuf::from("test.md"));
        assert!(changeset.is_none());
    }

    #[test]
    fn test_bump_ordering() {
        assert!(Bump::Patch < Bump::Minor);
        assert!(Bump::Minor < Bump::Major);

        let mut bumps = vec![Bump::Major, Bump::Patch, Bump::Minor];
        bumps.sort();
        assert_eq!(bumps, vec![Bump::Patch, Bump::Minor, Bump::Major]);
    }

    #[test]
    fn test_detect_changesets_dir_default() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let workspace = temp_dir.path();

        let changesets_dir = detect_changesets_dir(workspace);
        assert_eq!(changesets_dir, workspace.join(".sampo").join("changesets"));
    }

    #[test]
    fn test_append_changes_section() {
        let mut output = String::new();
        let changes = vec!["Fix bug A".to_string(), "Add feature B".to_string()];

        append_changes_section(&mut output, "Major changes", &changes);

        let expected = "### Major changes\n\n- Fix bug A\n- Add feature B\n\n";
        assert_eq!(output, expected);
    }

    #[test]
    fn test_append_changes_section_empty() {
        let mut output = String::new();
        let changes: Vec<String> = vec![];

        append_changes_section(&mut output, "Major changes", &changes);

        assert_eq!(output, "");
    }
}
